# -*- coding: utf-8 -*-
"""Copy of spotify-recommendation-engine.ipynb
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/1V_1tkHD6-20BWejyYcVGxNTvtrcNMZch

"""

import pandas as pd
import numpy as np
import json
import re
import sys
import itertools
from skimage import io
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt

import warnings
warnings.filterwarnings("ignore")

import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from spotipy.oauth2 import SpotifyOAuth
import spotipy.util as util


#If you're not familiar with this, save it! Makes using jupyter notebook on laptops much easier
from IPython.core.display import display, HTML
display(HTML("<style>.container { width:90% !important; }</style>"))

#another useful command to make data exploration easier
# NOTE: if you are using a massive dataset, this could slow down your code.
pd.set_option('display.max_columns', None)
pd.set_option("display.max_rows", None)


def load_data():
    spotify_df = pd.read_csv("spotify_data.csv")
    data_w_genre = pd.read_csv('spotify_data.csv')
    data_w_genre['genres_upd'] = data_w_genre.apply(
        lambda row: [row['playlist_genre'], row['playlist_subgenre']],
        axis=1
    )
    spotify_df['artists_upd_v1'] = spotify_df['track_artist'].str.split(',').apply(lambda x: [i.strip() for i in x])

    spotify_df['artists_upd_v2'] = spotify_df['track_artist'].apply(lambda x: re.findall('\"(.*?)\"',x))
    spotify_df['artists_upd'] = np.where(spotify_df['artists_upd_v1'].apply(lambda x: not x), spotify_df['artists_upd_v2'], spotify_df['artists_upd_v1'] )
    
    spotify_df['artists_song'] = spotify_df.apply(lambda row: row['artists_upd'][0]+row['track_name'],axis = 1)

    spotify_df.sort_values(['artists_song','track_album_release_date'], ascending = False, inplace = True)

    spotify_df.drop_duplicates('artists_song',inplace = True)

    return spotify_df, data_w_genre


def enrich_with_genres(spotify_df, data_w_genre):    
    artists_exploded = spotify_df[['artists_upd','id']].explode('artists_upd')
    artists_exploded_enriched = artists_exploded.merge(data_w_genre, how = 'left', left_on = 'artists_upd',right_on = 'track_artist')
    artists_exploded_enriched_nonnull = artists_exploded_enriched[~artists_exploded_enriched.genres_upd.isnull()]

    artists_exploded_enriched = artists_exploded.merge(
        data_w_genre.drop(columns=['id']),
        how='left',
        left_on='artists_upd',
        right_on='track_artist'
    )
    artists_exploded_enriched_nonnull = artists_exploded_enriched[~artists_exploded_enriched.genres_upd.isnull()]

    """Alright we're almost their, now we need to:
    1. Group by on the song `id` and essentially create lists lists
    2. Consilidate these lists and output the unique values
    """
    artists_genres_consolidated = artists_exploded_enriched_nonnull.groupby('id')['genres_upd'].apply(list).reset_index()
    artists_genres_consolidated['consolidates_genre_lists'] = artists_genres_consolidated['genres_upd'].apply(lambda x: list(set(list(itertools.chain.from_iterable(x)))))
    
    spotify_df = spotify_df.merge(artists_genres_consolidated[['id','consolidates_genre_lists']], on = 'id',how = 'left')

    """## 2. Feature Engineering
    ### - Normalize float variables
    ### - OHE Year and Popularity Variables
    ### - Create TF-IDF features off of artist genres
    """

    spotify_df['year'] = spotify_df['track_album_release_date'].apply(lambda x: x.split('-')[0])
    float_cols = spotify_df.dtypes[spotify_df.dtypes == 'float64'].index.values

    ohe_cols = 'track_popularity'
    spotify_df['track_popularity'].describe()

    # create 5 point buckets for popularity
    spotify_df['popularity_red'] = spotify_df['track_popularity'].apply(lambda x: int(x/5))

    # tfidf can't handle nulls so fill any null values with an empty list
    spotify_df['consolidates_genre_lists'] = spotify_df['consolidates_genre_lists'].apply(lambda d: d if isinstance(d, list) else [])

    return spotify_df, data_w_genre, float_cols, ohe_cols

#simple function to create OHE features
#this gets passed later on
def ohe_prep(df, column, new_name):
    """
    Create One Hot Encoded features of a specific column
    Parameters:
        df (pandas dataframe): Spotify Dataframe
        column (str): Column to be processed
        new_name (str): new column name to be used
    Returns:
        tf_df: One hot encoded features
    """

    tf_df = pd.get_dummies(df[column])
    feature_names = tf_df.columns
    tf_df.columns = [new_name + "|" + str(i) for i in feature_names]
    tf_df.reset_index(drop = True, inplace = True)
    return tf_df


#function to build entire feature set
def create_feature_set(df, float_cols):
    """
    Process spotify df to create a final set of features that will be used to generate recommendations
    Parameters:
        df (pandas dataframe): Spotify Dataframe
        float_cols (list(str)): List of float columns that will be scaled
    Returns:
        final: final set of features
    """

    #tfidf genre lists
    tfidf = TfidfVectorizer()
    tfidf_matrix =  tfidf.fit_transform(df['consolidates_genre_lists'].apply(lambda x: " ".join(x)))
    genre_df = pd.DataFrame(tfidf_matrix.toarray())
    genre_df.columns = ['genre' + "|" + i for i in tfidf.get_feature_names_out()]
    genre_df.reset_index(drop = True, inplace=True)

    #explicity_ohe = ohe_prep(df, 'explicit','exp')
    year_ohe = ohe_prep(df, 'year','year') * 0.5
    popularity_ohe = ohe_prep(df, 'popularity_red','pop') * 0.15

    #scale float columns
    floats = df[float_cols].reset_index(drop = True)
    scaler = MinMaxScaler()
    floats_scaled = pd.DataFrame(scaler.fit_transform(floats), columns = floats.columns) * 0.2

    #concanenate all features
    final = pd.concat([genre_df, floats_scaled, popularity_ohe, year_ohe], axis = 1)
    #add song id
    final['id']=df['id'].values

    return final


def get_spotify_client():
    client_id = 'b58f97e2f31249428194375fd2b32103'
    client_secret = '1ee79e07e44d49a3a289b76157d96968'

    if len(sys.argv) > 1:
        username = sys.argv[1]
    else:
        print("Usage: %s username" % (sys.argv[0],))
        sys.exit()

    auth_manager = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
    token = util.prompt_for_user_token(
        scope='user-library-read playlist-read-private playlist-read-collaborative',
        client_id=client_id,
        client_secret=client_secret,
        redirect_uri='http://127.0.0.1:3000/'
    )
    return spotipy.Spotify(auth=token, requests_timeout=10)

"""## 3. Connect to Spotify API

Useful links:
1. https://developer.spotify.com/dashboard/
2. https://spotipy.readthedocs.io/en/2.16.1/
"""

def create_necessary_outputs(sp, playlist_name, id_dic, df):
    playlist = pd.DataFrame()
    for ix, i in enumerate(sp.playlist(id_dic[playlist_name])['tracks']['items']):
        playlist.loc[ix, 'artist'] = i['track']['artists'][0]['name']
        playlist.loc[ix, 'name'] = i['track']['name']
        playlist.loc[ix, 'id'] = i['track']['id']
        playlist.loc[ix, 'date_added'] = i['added_at']
    playlist['date_added'] = pd.to_datetime(playlist['date_added'])
    playlist = playlist[playlist['id'].isin(df['id'].values)].sort_values('date_added', ascending=False)
    
    print(f"Fetching playlist: {playlist_name}, ID: {id_dic[playlist_name]}")
    tracks = sp.playlist(id_dic[playlist_name])['tracks']['items']
    print(f"Number of tracks fetched: {len(tracks)}")
    for i in tracks[:3]:
        print(i['track']['name'], i['track']['id'])
    print(f"After filtering by df['id']: {len(playlist)} tracks")

    return playlist


def visualize_songs(df):
    """
    Visualize cover art of the songs in the inputted dataframe
    Parameters:
        df (pandas dataframe): Playlist Dataframe
    """
    temp = df['url'].values
    plt.figure(figsize=(15,int(0.625 * len(temp))))
    columns = 5

    for i, url in enumerate(temp):
        plt.subplot(len(temp) / columns + 1, columns, i + 1)

        image = io.imread(url)
        plt.imshow(image)
        plt.xticks(color = 'w', fontsize = 0.1)
        plt.yticks(color = 'w', fontsize = 0.1)
        plt.xlabel(df['name'].values[i], fontsize = 12)
        plt.tight_layout(h_pad=0.4, w_pad=0)
        plt.subplots_adjust(wspace=None, hspace=None)

    plt.show()

def generate_playlist_data():
    spotify_df, data_w_genre  = load_data()
    spotify_df, data_w_genre, float_cols, ohe_cols = enrich_with_genres(spotify_df, data_w_genre)
    complete_feature_set = create_feature_set(spotify_df, float_cols=float_cols)#.mean(axis = 0)
    sp = get_spotify_client()

    # Get playlist mappings
    id_name = {}
    list_photo = {}
    for i in sp.current_user_playlists()['items']:
        id_name[i['name']] = i['uri'].split(':')[2]
        list_photo[i['uri'].split(':')[2]] = i['images'][0]['url']
    return spotify_df, sp, complete_feature_set, id_name

def generate_playlist_feature(playlist_df, weight_factor):
    spotify_df, sp, complete_feature_set, id_name = generate_playlist_data()

    complete_feature_set_playlist = complete_feature_set[complete_feature_set['id'].isin(playlist_df['id'].values)]#.drop('id', axis = 1).mean(axis =0)
    complete_feature_set_playlist = complete_feature_set_playlist.merge(playlist_df[['id','date_added']], on = 'id', how = 'inner')
    complete_feature_set_nonplaylist = complete_feature_set[~complete_feature_set['id'].isin(playlist_df['id'].values)]#.drop('id', axis = 1)

    playlist_feature_set = complete_feature_set_playlist.sort_values('date_added',ascending=False)
    most_recent_date = playlist_feature_set.iloc[0,-1]

    for ix, row in playlist_feature_set.iterrows():
        playlist_feature_set.loc[ix,'months_from_recent'] = int((most_recent_date.to_pydatetime() - row.iloc[-1].to_pydatetime()).days / 30)

    playlist_feature_set['weight'] = playlist_feature_set['months_from_recent'].apply(lambda x: weight_factor ** (-x))
    playlist_feature_set_weighted = playlist_feature_set.copy()
    #print(playlist_feature_set_weighted.iloc[:,:-4].columns)
    playlist_feature_set_weighted.update(playlist_feature_set_weighted.iloc[:,:-4].mul(playlist_feature_set_weighted.weight,0))
    playlist_feature_set_weighted_final = playlist_feature_set_weighted.iloc[:, :-4]
    #playlist_feature_set_weighted_final['id'] = playlist_feature_set['id']

    return playlist_feature_set_weighted_final.sum(axis = 0), complete_feature_set_nonplaylist


"""## 5. Generate Recommendations"""
def generate_playlist_recos(df, sp, features, nonplaylist_features):
    """
    Pull songs from a specific playlist.
    Parameters:
        df (pandas dataframe): spotify dataframe
        features (pandas series): summarized playlist feature
        nonplaylist_features (pandas dataframe): feature set of songs that are not in the selected playlist
    Returns:
        non_playlist_df_top_40: Top 40 recommendations for that playlist
    """
    # Make sure there are no NaNs
    if nonplaylist_features.drop('id', axis=1).isnull().values.any():
        print("NaNs found in nonplaylist_features. Dropping rows with NaNs...")
        nonplaylist_features = nonplaylist_features.dropna()

    if pd.isnull(features).any():
        print("NaNs found in features vector. Replacing with 0...")
        features = np.nan_to_num(features)

    non_playlist_df = df[df['id'].isin(nonplaylist_features['id'].values)]
    non_playlist_df['sim'] = cosine_similarity(nonplaylist_features.drop('id', axis = 1).values, features.values.reshape(1, -1))[:,0]
    non_playlist_df_top_40 = non_playlist_df.sort_values('sim',ascending = False).head(40)
    non_playlist_df_top_40['url'] = non_playlist_df_top_40['id'].apply(lambda x: sp.track(x)['album']['images'][1]['url'])

    return non_playlist_df_top_40

def main(): 
    results = {}

    spotify_df, sp, complete_feature_set, id_name = generate_playlist_data()

    # for playlist_name, playlist_id in id_name.items():

    #     playlist = create_necessary_outputs(sp, playlist_name, id_name, spotify_df)
    #     if playlist is None or playlist.empty:
    #         continue

    #     vec_playlist, vec_nonplaylist = generate_playlist_feature(playlist, 1.09)
    #     top40 = generate_playlist_recos(spotify_df, sp, vec_playlist, vec_nonplaylist)

    #     results[playlist_id] = {
    #         'top40': top40.to_dict(orient="records")
    #     }

    count = 0

    for playlist_name, playlist_id in id_name.items():

        if count == 1: break # Avoid to generate many recommendations, reduce runtime
        else:
            playlist = create_necessary_outputs(sp, playlist_name, id_name, spotify_df)
            if playlist is None or playlist.empty:
                continue

            vec_playlist, vec_nonplaylist = generate_playlist_feature(playlist, 1.09)
            top40 = generate_playlist_recos(spotify_df, sp, vec_playlist, vec_nonplaylist)

            results[playlist_id] = {
                'top40': top40.to_dict(orient="records")
            }
            count = count + 1 # Generate one recommendation based on the first playlist


    return results

if __name__ == "__main__":
    results = main()
